
& 리뷰(궁금한내용)은 코드에도 주석으로 달아놨지만 보기시 편하시라고 따로 텍스트 파일 만들었습니다.
-> 저도 그렇게 할 걸 그랬네요 이렇게 해주니까 아주 보기 편합니다 

전반적으로 저보다 훨씬 잘하시는 분의 코드를 보고 많이 배웠습니다!
코드 전반적으로 주석이 깔끔하게 달려 있어 논리의 흐름이 어지럽지 않고 깔끔하게 흘러가서 너무 보기 편했습니다.
very very very very very very LGTM 입니다.
-> 처음에 개념 정리를 하면서 달았던 건데 이전에 구현한 코드 복붙하고 고치면서 주석과 코드가 안 맞는 경우가 있기도 할거라
   실무에서 작성하게 된다면 역시 류석영 교수님이 말씀해주신 것처럼 테스트 드리븐으로 하고 주석은 잘 요약해서 정리해봐야겠네요 

implicit

- 할당 가능 여부를 따로 정의해놓으신것이 훨씬 직관적으로 사용할 수 있어서 좋습니다.
#define CAN_ALLOC(p, size) !GET_ALLOC(HDRP(p)) && (size <= GET_SIZE(HDRP(p)))

-> 이후에 explicit, seglist 에서도 쓰일까 싶어서 매크로로 만들었는데 나중에 생각해보니 다른 리스트 구조는 가용 블록만 들어가 있어서
   가용 여부를 확인할 필요가 없어져서 implicit 만 사용했습니다

- 어제 nextfit의 포인터를 coalesce에 놓아도 되는지 질문했고 명확한 답변을 주셔서 감사했습니다. 저는 단순히 next_fitp = bp;만 추가했었는데 따로 조건을 걸어 놓으신게 좋아보입니다.
#ifdef NEXT_FIT
    if (next_fitp > bp && next_fitp < NEXT_BLKP(bp))
        next_fitp = bp;
#endif


- ifdef는 처음봅니다!! ifdef으로 깔끔하게 firstfit nextfit 스위칭 하는게 좋네요 그리고 for문 처음 인자를 안줘도 되는줄 처음알았습니다.

static void *find_fit(size_t asize){
    /* Next-fit search */
#ifdef NEXT_FIT
-> 다른 코드에서 이런 식으로 해놓은 게 있어서 해봤는데 편한 점도 있고 때로는 더 귀찮아지기도 했는데 알아두고 필요할 때 사용해봐도 좋을 것 같네요



explicit

- byeBlock의 함수명은 explict의 개념이 없이면 조금 이해하기 힘든 함수명일 수 있을거라 생각합니다!
함수명이 조금 길더라도 remove_block_from_freelist와 같이 조금더 직관적이면 좋을거 같아요! 물론 바이블록도 좋긴합니다 !
static void byeBlock(void *bp);
-> 가용 리스트에서 블록을 제거하는 함수를 만들면서 어떤 이름을 할까하다가 정한 이름인데 재미있는 이름이지만
   실무에서는 좀 더 직관적인 함수명을 사용한다는 데 공감합니다 


- 테스트 하시고 지우실 예정이셨겠지만 무슨 테스트인지 궁금합니다!
#ifdef TEST
    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)
        return -1;
    PUT(heap_listp, 0);
-> 초기화 되는 블록들을 건드려가면서 각각의 블록의 역할이 뭘지 추측해보고 최소화 블록 크기를 줄여보고 하는 테스트를 하면서 남은 코드인 것 같네요
   참고로 테스트 해보니 초기 블록이 2개만 있어도 돌아가는 경우도 있었습니다

- (long)자료형을 꼭 써야 하는건가요~~?
- 자문자답 32bit에서는 long이 4byte, 64bit에서는 long이 8byte이고, 포인터도 각각 32에서는 4 바이트, 64에서는 8 바이트이기 때문에 사용하는거군요.
- 저는 제 코드에서는 그냥 없이 했는데 다양한 운영체제 bit에 맞추기 위해서는 long을 써야하군요!

/* mem_sbrk를 통해 break를 뒤로 옮겨 힙 공간을 size만큼 키운다 */
if ((long)(bp = mem_sbrk(asize)) == -1)
    return NULL;
-> long은 사실 딱히 먼저 생각을 하고 붙인 게 아니라 책에 있는 implicit 코드를 가져오면서 그대로 놔둔 거였는데 나중에 다른 사람들과 이야기 하면서
   아마 적어놓은 것처럼 64bit에서 포인터의 크기를 고려한 게 아닐까 추측하고 있습니다